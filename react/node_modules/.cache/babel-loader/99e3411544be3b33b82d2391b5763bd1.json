{"ast":null,"code":"/**\n *  基于fetch 在浏览器中发送请求库的封装\n */\nexport const http = {\n  // 弹出\"菊花\"效果\n  showLoading: function () {// Toast.loading(\"请求中\", 5000, function () {\n    //     console.log('close');\n    // }, true);\n  },\n  // 关闭 \"菊花\" 效果\n  hideLoading: function () {// Toast.hide();\n  },\n  // 在header中添加token\n  setTokenInHeader: function () {},\n  // json 转为 get请求的字符串\n  json_to_get: function (jsonObj) {\n    return Object.keys(jsonObj).map(function (key) {\n      // body...\n      return encodeURIComponent(key) + \"=\" + encodeURIComponent(jsonObj[key]);\n    }).join(\"&\");\n  },\n  // get 请求字符串转为json\n  get_to_json: function (sstr) {\n    sstr = sstr.replace(/&/g, '\",\"').replace(/=/g, '\":\"');\n    sstr = '{\"' + sstr + '\"}';\n  },\n  fetchAction: function (url, fetchConfig) {\n    var that = this;\n    return new Promise(function (resolve, reject) {\n      fetch(url, fetchConfig) // then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。\n      // 第一个then的response返回的是 服务器响应的信息 —— 包括 header content-type body 等信息\n      // 只要不是后台报错，响应都是成功的，比如 404 ，403， 500等是成功返回\n      .then(function (response) {\n        // 如果是成功返回\n        if (response.ok) {\n          // 这个函数返回的是接口响应的值，执行后面的then 方法\n          return response.json();\n        } else {\n          // 后台报错，执行后面的catch方法\n          reject({\n            status: response.status\n          });\n        }\n      }).then(function (response) {\n        resolve(response);\n      }).catch(function (err) {\n        reject({\n          status: -1\n        });\n      }) // 无论成功和失败，都需要执行该方法，用来关闭菊花效果\n      .finally(function () {\n        that.hideLoading();\n      });\n    });\n  },\n\n  /**\n   * 基于 fetch 封装的 GET请求\n   * @param url\n   * @param params {}\n   * @param headers\n   * @returns {Promise}\n   */\n  get: function (url, params, headers) {\n    var that = this;\n    this.showLoading();\n    var headerObj = {};\n\n    if (params) {\n      var paramsArray = []; //encodeURIComponent\n\n      Object.keys(params).forEach(function (key) {\n        paramsArray.push(key + '=' + params[key]);\n      });\n\n      if (url.search(/\\?/) === -1) {\n        url += '?' + paramsArray.join('&');\n      } else {\n        url += '&' + paramsArray.join('&');\n      }\n    } // 判断用户是否添加了值\n\n\n    if (headers === undefined) {\n      headerObj = {};\n    } else {\n      headerObj = headers;\n    } // 设置token在header中\n\n\n    this.setTokenInHeader(headerObj);\n    var fetchConfig = {\n      method: 'GET',\n      headers: headerObj\n    };\n    return that.fetchAction(url, fetchConfig);\n  },\n\n  /**\n   * 基于 fetch 封装的 POST请求  FormData 表单数据\n   * @param url\n   * @param formData\n   * @param headers\n   * @returns {Promise}\n   */\n  post: function (url, params, headers) {\n    var that = this;\n    this.showLoading();\n    var formDataObj = null; // 传递的参数\n\n    var headerObj = {}; // 设置请求头对象\n\n    if (params === undefined) {\n      formDataObj = \"\";\n    } else {\n      // 判断传递过来的是否是对象，如果是JSON 对象，需要序列化JSON数据，后台才能接受的刀\n      if (params instanceof Object) {\n        formDataObj = that.json_to_get(params);\n      } else {\n        // 如果不是JSON，则直接使用用户传递过来的值\n        formDataObj = params;\n      }\n    } // 判断用户是否添加了值\n\n\n    if (headers === undefined) {\n      headerObj['Content-type'] = 'application/x-www-form-urlencoded';\n    } else {\n      headerObj = headers;\n    } // 设置token在header中\n\n\n    this.setTokenInHeader(headerObj);\n    var fetchConfig = {\n      method: 'POST',\n      mode: 'cors',\n      headers: headerObj,\n      body: formDataObj\n    };\n    return that.fetchAction(url, fetchConfig);\n  },\n  postUpload: function (url, formdata, headers) {\n    var that = this;\n    this.showLoading();\n    var uploadReq = new Request('http://localhost:3000/fetch/upload', {\n      //url为服务器接口URL\n      method: \"POST\",\n      body: formdata\n    });\n    return new Promise(function (resolve, reject) {\n      fetch(uploadReq) // then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。\n      // 第一个then的response返回的是 服务器响应的信息 —— 包括 header content-type body 等信息\n      // 只要不是后台报错，响应都是成功的，比如 404 ，403等是成功返回\n      .then(function (response) {\n        // 如果是成功返回\n        if (response.ok) {\n          // response.json读取服务器发来的JSON数据，response.json返回Promise，所以可以链式调用.then方法\n          return response.json();\n        } else {\n          // 后台报错，执行后面的catch方法\n          reject({\n            status: response.status\n          });\n        }\n      }).then(function (response) {\n        resolve(response);\n      }).catch(function (err) {\n        reject({\n          status: -1\n        });\n      }) // 无论成功和失败，都需要执行该方法，用来关闭菊花效果\n      .finally(function () {\n        that.hideLoading();\n      });\n    });\n  }\n};","map":{"version":3,"sources":["/Users/dongbo/Desktop/react/src/api/api.js"],"names":["http","showLoading","hideLoading","setTokenInHeader","json_to_get","jsonObj","Object","keys","map","key","encodeURIComponent","join","get_to_json","sstr","replace","fetchAction","url","fetchConfig","that","Promise","resolve","reject","fetch","then","response","ok","json","status","catch","err","finally","get","params","headers","headerObj","paramsArray","forEach","push","search","undefined","method","post","formDataObj","mode","body","postUpload","formdata","uploadReq","Request"],"mappings":"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","sourcesContent":["/**\n *  基于fetch 在浏览器中发送请求库的封装\n */\nexport const\nhttp = {\n    // 弹出\"菊花\"效果\n    showLoading: function () {\n        // Toast.loading(\"请求中\", 5000, function () {\n        //     console.log('close');\n        // }, true);\n    },\n    // 关闭 \"菊花\" 效果\n    hideLoading: function () {\n        // Toast.hide();\n    },\n    // 在header中添加token\n    setTokenInHeader: function () {\n\n    },\n    // json 转为 get请求的字符串\n    json_to_get: function (jsonObj) {\n        return Object.keys(jsonObj).map(function (key) {\n            // body...\n            return encodeURIComponent(key) + \"=\" + encodeURIComponent(jsonObj[key]);\n        }).join(\"&\");\n    },\n    // get 请求字符串转为json\n    get_to_json: function (sstr) {\n        sstr = sstr.replace(/&/g, '\",\"').replace(/=/g, '\":\"');\n        sstr = '{\"' + sstr + '\"}';\n    },\n    fetchAction: function (url, fetchConfig) {\n        var that = this;\n        return new Promise(function (resolve, reject) {\n            fetch(url, fetchConfig)\n            // then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。\n            // 第一个then的response返回的是 服务器响应的信息 —— 包括 header content-type body 等信息\n            // 只要不是后台报错，响应都是成功的，比如 404 ，403， 500等是成功返回\n            .then(function (response) {\n                // 如果是成功返回\n                if (response.ok) {\n                    // 这个函数返回的是接口响应的值，执行后面的then 方法\n                    return response.json();\n                } else {\n                    // 后台报错，执行后面的catch方法\n                    reject({\n                        status: response.status\n                    })\n                }\n            })\n            .then(function (response) {\n                resolve(response);\n            })\n            .catch (function (err) {\n                reject({\n                    status: -1\n                });\n            })\n            // 无论成功和失败，都需要执行该方法，用来关闭菊花效果\n            .finally(function () {\n                that.hideLoading();\n            })\n        });\n    },\n\n    /**\n     * 基于 fetch 封装的 GET请求\n     * @param url\n     * @param params {}\n     * @param headers\n     * @returns {Promise}\n     */\n    get: function (url, params, headers) {\n        var that = this;\n        this.showLoading();\n        var headerObj = {};\n        if (params) {\n            var paramsArray = [];\n            //encodeURIComponent\n            Object.keys(params).forEach(function (key) {\n                paramsArray.push(key + '=' + params[key])\n            });\n            if (url.search(/\\?/) === -1) {\n                url += '?' + paramsArray.join('&')\n            } else {\n                url += '&' + paramsArray.join('&')\n            }\n        }\n        // 判断用户是否添加了值\n        if (headers === undefined) {\n            headerObj = {};\n        } else {\n            headerObj = headers;\n        }\n        // 设置token在header中\n        this.setTokenInHeader(headerObj);\n\n        var fetchConfig = {\n            method: 'GET',\n            headers: headerObj,\n        }\n        return that.fetchAction(url, fetchConfig);\n    },\n    /**\n     * 基于 fetch 封装的 POST请求  FormData 表单数据\n     * @param url\n     * @param formData\n     * @param headers\n     * @returns {Promise}\n     */\n    post: function (url, params, headers) {\n        var that = this;\n        this.showLoading();\n        var formDataObj = null; // 传递的参数\n        var headerObj = {}; // 设置请求头对象\n        if (params === undefined) {\n            formDataObj = \"\";\n        } else {\n            // 判断传递过来的是否是对象，如果是JSON 对象，需要序列化JSON数据，后台才能接受的刀\n            if (params instanceof Object) {\n                formDataObj = that.json_to_get(params)\n            } else { // 如果不是JSON，则直接使用用户传递过来的值\n                formDataObj = params;\n            }\n        }\n        // 判断用户是否添加了值\n        if (headers === undefined) {\n            headerObj['Content-type'] = 'application/x-www-form-urlencoded';\n        } else {\n            headerObj = headers;\n        }\n        // 设置token在header中\n        this.setTokenInHeader(headerObj);\n        var fetchConfig = {\n            method: 'POST',\n            mode: 'cors',\n            headers: headerObj,\n            body: formDataObj,\n        };\n        return that.fetchAction(url, fetchConfig);\n    },\n    postUpload: function (url, formdata, headers) {\n        var that = this;\n        this.showLoading();\n        var uploadReq = new Request('http://localhost:3000/fetch/upload', { //url为服务器接口URL\n            method: \"POST\",\n            body: formdata\n        });\n        return new Promise(function (resolve, reject) {\n            fetch(uploadReq)\n            // then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。\n            // 第一个then的response返回的是 服务器响应的信息 —— 包括 header content-type body 等信息\n            // 只要不是后台报错，响应都是成功的，比如 404 ，403等是成功返回\n                .then(function (response) {\n                    // 如果是成功返回\n                    if (response.ok) {\n                        // response.json读取服务器发来的JSON数据，response.json返回Promise，所以可以链式调用.then方法\n                        return response.json();\n                    } else {\n                        // 后台报错，执行后面的catch方法\n                        reject({\n                            status: response.status\n                        })\n                    }\n                })\n                .then(function (response) {\n                    resolve(response);\n                })\n                .catch (function (err) {\n                    reject({\n                        status: -1\n                    });\n                })\n                // 无论成功和失败，都需要执行该方法，用来关闭菊花效果\n                .finally(function () {\n                    that.hideLoading();\n                })\n        });\n    }\n};\n"]},"metadata":{},"sourceType":"module"}